classdef TestTomlDecode < matlab.unittest.TestCase

  properties (TestParameter)
    validInput = struct( ...
        'comment_fullLine', {{ ...
            sprintf('\n# this is a comment\n') ...
          , struct() ...
          , 'Improper interpretation of a comment' ...
                   }} ...
      , 'bareKey_underscore', {{ ...
            'key_text = "value"' ...
          , struct('key_text', 'value') ...
          , 'Did not accept a bare key with an underscore.' ...
                   }} ...
      , 'bareKey_hyphen', {{ ...
          'key-text = "value"' ...
        , struct('key_text', 'value') ...
        , 'Did not accept a bare key with a dash.' ...
                   }} ...
      , 'bareKey_asciiDigit', {{ ...
          'key123 = "value"' ...
        , struct('key123', 'value') ...
        , 'Did not accept a bare key with digits.' ...
                   }} ...
      , 'bareKey_uppercase', {{ ...
          'KEY = "value"' ...
        , struct('KEY', 'value') ...
        , 'Did not accept a bare key with uppercase ASCII.' ...
                   }} ...
      , 'bareKey_allDigits', {{ ...
          '1234 = "value"' ...
        , struct('f1234', 'value') ...
        , 'Did not accept a bare key with only ASCII digits.' ...
                   }} ...
      , 'quotedKey_dotted', {{ ...
          '"127.0.0.1" = "value"' ...
        , struct('f127_0_0_1', 'value') ...
        , 'Did not handle quoted key with invalid format correctly.' ...
                   }} ...
      , 'quotedKey_spaced', {{ ...
          '"character encoding" = "value"' ...
        , struct('character_encoding', 'value') ...
        , 'Did not handle quoted key with space correctly.' ...
                   }} ...
      , 'quotedKey_single', {{ ...
          '''key2'' = "value"' ...
        , struct('key2', 'value') ...
        , 'Did not handle single-quoted key correctly.' ...
                   }} ...
      , 'quotedKey_nested', {{ ...
          '''quoted "value"'' = "value"' ...
        , struct('quoted_value', 'value') ...
        , 'Did not handle nested quoting in key correctly.' ...
                   }} ...
      , 'quotedKey_empty', {{ ...
          '"" = "value"' ...
        , struct('f', 'value') ...
        , 'Did not handle empty quoted key correctly.' ...
                   }} ...
      , 'dottedKey_basic', {{ ...
          'abc.def.ghi = "value"' ...
        , struct('abc', struct('def', struct('ghi', 'value'))) ...
        , 'Did not handle dotted key correctly.' ...
                   }} ...
      , 'dottedKey_quoted', {{ ...
          'abc."def".ghi = "value"' ...
        , struct('abc', struct('def', struct('ghi', 'value'))) ...
        , 'Did not handle dotted and quoted key correctly.' ...
                   }} ...
      , 'dottedKey_nestedQuoting', {{ ...
          'abc."quoted ''value''".ghi = "value"' ...
        , struct('abc', struct('quoted_value', struct('ghi', 'value'))) ...
        , 'Did not handle nested quoting in dotted key correctly.' ...
                   }} ...
      , 'integer_decimal', {{ ...
          'key = 123' ...
        , struct('key', 123) ...
        , 'Did not parse a decimal integer correctly.' ...
                   }} ...
      , 'integer_negative', {{ ...
          'key = -10' ...
        , struct('key', -10) ...
        , 'Did not parse a negative decimal integer correctly.' ...
                   }} ...
      , 'integer_positive', {{ ...
          'key = +10' ...
        , struct('key', 10) ...
        , 'Did not parse a positive decimal integer correctly.' ...
                   }} ...
      , 'integer_binary', {{ ...
          'key = 0b101' ...
        , struct('key', 5) ...
        , 'Did not parse a binary integer correctly.' ...
                   }} ...
      , 'integer_octal', {{ ...
          'key = 0o1234567' ...
        , struct('key', 342391) ...
        , 'Did not parse an octal integer correctly.' ...
                   }} ...
      , 'integer_hexadecimal', {{ ...
          'key = 0xdecaf' ...
        , struct('key', 912559) ...
        , 'Did not parse a hexadecimal integer correctly.' ...
                   }} ...
      , 'integer_zero', {{ ...
          'key = 0' ...
        , struct('key', 0) ...
        , 'Did not parse integer zero correctly.' ...
                   }} ...
        );

    invalidInput= struct( ...
        'noValue', {{ ...
            'key = #' ...
          , 'toml:UnspecifiedValue' ...
          , 'Did not fail for unspecified value.' ...
                    }} ...
      , 'emptyBareKey', {{ ...
          sprintf('\nkey = "value"\n= "value2"') ...
        , 'toml:EmptyBareKey' ...
        , 'Did not fail for empty bare key.' ...
                   }} ...
      , 'decimalIntLeadingZeros_1', {{ ...
          'key = 01' ...
        , 'toml:DecIntLeadingZeros' ...
        , 'Did not raise an error for leading zeros on a decimal integer.' ...
                   }} ...
      , 'decimalIntLeadingZeros_2', {{ ...
          'key = 000123' ...
        , 'toml:DecIntLeadingZeros' ...
        , 'Did not raise an error for leading zeros on a decimal integer.' ...
                   }} ...
      , 'upperCaseBoolean_1', {{ ...
          'key = True' ...
        , 'toml:UppercaseBoolean' ...
        , 'Did not raise an error for uppercase Boolean values.' ...
                   }} ...
      , 'upperCaseBoolean_2', {{ ...
          'key = FALSE' ...
        , 'toml:UppercaseBoolean' ...
        , 'Did not raise an error for uppercase Boolean values.' ...
                   }} ...
      , 'nameCollision', {{ ...
          sprintf(['[[fruit]]\nname = "apple"\n\n' ...
                   '[[fruit.variety]]\nname = "red delicious"\n\n' ...
                   '[fruit.variety]\nname = "granny smith"']) ...
        , 'toml:NameCollision' ...
        , 'Did not reject a name collision between an array and a table.' ...
                   }} ...
      , 'heterogeneousArray', {{ ...
          'key = [1, "abc"]' ...
        , 'toml:HeterogeneousArray' ...
        , 'Did not reject a heterogeneous array.' ...
                   }} ...
      , 'redefinedArray', {{ ...
          sprintf('fruit = []\n[[fruit]]') ...
        , 'toml:RedefinedArray' ...
        , 'Did not reject a redefined array.' ...
                   }} ...
      , 'redefinedTable_1', {{ ...
          sprintf('[a]\nb = 1\n\n[a]\nc = 2') ...
        , 'toml:RedefinedTable' ...
        , 'Did not reject a redefined table.' ...
                   }} ...
      , 'redefinedTable_2', {{ ...
          sprintf('[a]\nb = 1\n\n[a.b]\nc = 2') ...
        , 'toml:RedefinedTable' ...
        , 'Did not reject a redefined table.' ...
                   }} ...
      , 'validation_unquotedString', {{ ...
          'key = value' ...
        , 'toml:InvalidType' ...
        , 'Failed to reject invalid TOML data: identifier used as value.' ...
                   }} ...
      , 'validation_undefinedInteger', {{ ...
          'key = 0q123' ...
        , 'toml:InvalidType' ...
        , 'Failed to reject invalid TOML data: invalid integer format.' ...
                   }} ...
      , 'validation_rawHTML', {{ ...
          'key = <a href="github.com">good stuff here</a>' ...
        , 'toml:InvalidType' ...
        , 'Failed to reject invalid TOML data: unquoted HTML.' ...
                   }} ...
      , 'validation_rawJSON', {{ ...
          'key = {"key1": null, "key2": true}' ...
        , 'toml:InvalidType' ...
        , 'Failed to reject invalid TOML data: unquoted JSON.' ...
                   }} ...
      , 'validation_unquotedCurlyBrace', {{ ...
          'key = }' ...
        , 'toml:InvalidType' ...
        , 'Failed to reject invalid TOML data: unquoted symbol.' ...
                   }} ...
      , 'validation_unquotedSquareBracket', {{ ...
          'key = ]' ...
        , 'toml:InvalidType' ...
        , 'Failed to reject invalid TOML data: unquoted symbol.' ...
                   }} ...
      , 'validation_unquotedDot', {{ ...
          'key = .' ...
        , 'toml:InvalidType' ...
        , 'Failed to reject invalid TOML data: unquoted symbol.' ...
                   }} ...
      , 'validation_incompleteArray', {{ ...
          'key = ["abcd", "efgh"' ...
        , 'toml:IncompleteArray' ...
        , 'Failed to reject invalid TOML data: unclosed array.' ...
                   }} ...
      , 'validation_incompleteStringDouble', {{ ...
          'key = "abcd' ...
        , 'toml:IncompleteString' ...
        , 'Failed to reject invalid TOML data: unclosed double quote.' ...
                   }} ...
      , 'validation_incompleteStringSingle', {{ ...
          'key = ''abcd' ...
        , 'toml:IncompleteString' ...
        , 'Failed to reject invalid TOML data: unclosed single quote.' ...
                   }} ...
      , 'validation_incompleteTable', {{ ...
          'key = {subkey = "value"' ...
        , 'toml:IncompleteInlineTable' ...
        , 'Failed to reject invalid TOML data: unclosed inline table.' ...
                   }} ...
      , 'validation_incompleteStringWithTrailingLine', {{ ...
          sprintf('key1 = "abcd\nkey2 = 1234') ...
        , 'toml:IncompleteString' ...
        , ['Failed to reject invalid TOML data: unclosed double quote with ' ...
           'data on the following line.'] ...
                   }} ...
      , 'validation_incompleteMultilineString', {{ ...
          sprintf('key1 = """\nabcd\nefgh\n') ...
        , 'toml:IncompleteString' ...
        , 'Failed to reject invalid TOML data: unclosed multiline string.' ...
                   }} ...
        );
  end

  methods (Test, ParameterCombination = 'sequential')

    function testValidInputs(testCase, validInput)
      testCase.verifyEqual(toml.decode(validInput{1}), validInput{2:3})
    end

    function testInvalidInputs(testCase, invalidInput)
      testCase.verifyError(@() toml.decode(invalidInput{1}), invalidInput{2:3})
    end

  end

  methods (Access = private)

    % Simple way to run tests repeatedly
    function runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
      if ischar(error_msg)
        error_msg = repmat({error_msg}, size(toml_str));
      end

      for indx = 1:length(toml_str)
        testCase.verifyEqual(toml.decode(toml_str{indx}), ...
                             matlab_strct{indx}, error_msg{indx})
      end
    end

  end

  methods (Test)

    function testFloats(testCase)
      toml_str = { ...
          'key = +1.0' ...
        , 'key = 3.1415' ...
        , 'key = -0.01' ...
        , 'key = 5e+22' ...
        , 'key = 1e6' ...
        , 'key = -2E-2' ...
        , 'key = 6.626e-34' ...
                 };

      matlab_strct = { ...
          struct('key', 1) ...
        , struct('key', 3.1415) ...
        , struct('key', -0.01) ...
        , struct('key', 5e22) ...
        , struct('key', 1e6) ...
        , struct('key', -2e-2) ...
        , struct('key', 6.626e-34) ...
                     };

      error_msg = { ...
          'Did not parse a positive float correctly.' ...
        , 'Did not parse a float correctly.' ...
        , 'Did not parse a negative float correctly.' ...
        , 'Did not parse an exponentiated float correctly.' ...
        , 'Did not parse an exponentiated float correctly.' ...
        , 'Did not parse an exponentiated float correctly.' ...
        , 'Did not parse a float with integral, fractional, and exponential parts correctly.' ...
                  };

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testSpecialFloats(testCase)
      % test cases
      toml_str = { ...
          'key = inf' ...
        , 'key = -inf' ...
        , 'key = INF' ...
        , 'key = nan' ...
        , 'key = -nan' ...
        , 'key = NaN' ...
                 };

      % test each case appropriately
      testCase.verifyEqual(toml.decode(toml_str{1}), struct('key', inf), ...
        'Did not parse infinity correctly')
      testCase.verifyEqual(toml.decode(toml_str{2}), struct('key', -inf), ...
        'Did not parse negative infinity correctly')
      testCase.verifyError(@() toml.decode(toml_str{3}), ...
       'toml:UppercaseSpecialFloat', ...
       'Did not raise an error for uppercase special float values.')
      testCase.verifyEqual(toml.decode(toml_str{4}), struct('key', NaN), ...
        'Did not parse infinity correctly')
      testCase.verifyEqual(toml.decode(toml_str{5}), struct('key', -NaN), ...
        'Did not parse negative infinity correctly')
      testCase.verifyError(@() toml.decode(toml_str{6}), ...
       'toml:UppercaseSpecialFloat', ...
       'Did not raise an error for uppercase special float values.')
    end

    function testBasicString(testCase)
      toml_str = { ...
          'key = "value"' ...
        , sprintf('key = "line 1\nline 2"') ...
        , 'key = "disappearing A\b"' ...
        , 'key = "escaped \"quote\" marks"' ...
        , 'key = "inline \u0075nicode"' ...
        , 'key = "inline \U00000055nicode"' ...
        , 'key = "escaped\ttab"' ...
                 };

      matlab_strct = { ...
          struct('key', 'value') ...
        , struct('key', sprintf('line 1\nline 2')) ...
        , struct('key', sprintf('disappearing A\b')) ...
        , struct('key', 'escaped "quote" marks') ...
        , struct('key', 'inline unicode') ...
        , struct('key', 'inline Unicode') ...
        , struct('key', sprintf('escaped\ttab')) ...
                     };

      error_msg = { ...
          'Did not parse a basic string successfully.' ...
        , 'Did not parse a basic string with a newline successfully.' ...
        , 'Did not parse a basic string with a backspace successfully.' ...
        , 'Did not parse a basic string with escaped quotes successfully.' ...
        , 'Did not parse a basic string with short Unicode successfully.' ...
        , 'Did not parse a basic string with long Unicode successfully.' ...
        , 'Did not parse a basic string with an escaped tab successfully.' ...
                  };

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testReservedEscapes(testCase)
      valid_esc = 'btnfr"\uU';
      all_glyphs = char(33:126);
      invalid_esc = setdiff(all_glyphs, valid_esc);

      for ch = invalid_esc
        str_to_parse = sprintf('key = "\\%s"', ch);
        testCase.verifyError(@() toml.decode(str_to_parse), ...
         'toml:InvalidEscapeSequence', ...
         ['Did not reject a reserved escape sequence: "\', ch, '"'])
      end
    end

    function testMultilineBasicString(testCase)
      toml_str1 = sprintf('key = """\nabcd"""');
      toml_str2 = sprintf('key = """line 1\n    line 2"""');
      toml_str3 = sprintf('key = """on the \\\n    same line"""');
      testCase.verifyEqual(toml.decode(toml_str1), ...
        struct('key', 'abcd'), ...
        'Did not parse a multiline basic string successfully.')
      testCase.verifyEqual(toml.decode(toml_str2), ...
        struct('key', sprintf('line 1\n    line 2')), ...
        'Did not parse a multiline basic string with indentation successfully.')
      testCase.verifyEqual(toml.decode(toml_str3), ...
        struct('key', sprintf('on the same line')), ...
        'Did not parse a multiline basic string with a LEB successfully.')
    end

    function testLiteralString(testCase)
      toml_str1 = 'key = ''C:\Users\example.txt''';
      toml_str2 = sprintf('key = ''''''\nNo leading newline here.''''''');
      testCase.verifyEqual(toml.decode(toml_str1), ...
       struct('key', 'C:\Users\example.txt'), ...
       'Did not parse a literal string with backslashes successfully.')
      testCase.verifyEqual(toml.decode(toml_str2), ...
       struct('key', 'No leading newline here.'), ...
       'Did not parse a literal string with a leading newline successfully.')
    end

    function testOffsetDateTime(testCase)
      % TOML version
      toml_str = { ...
          'odt = 1979-05-27T07:32:00Z' ...
        , 'odt = 1979-05-27T07:32:00-07:00' ...
        , 'odt = 1979-05-27T07:32:00.999999-07:00' ...
        , 'odt = 1979-05-27 07:32:00Z'...
                 };

      % matlab versions, respectively
      matl_obj = { ...
          datetime('1979-05-27 07:32:00', 'TimeZone', 'UTC') ...
        , datetime('1979-05-27 07:32:00-07:00', 'InputFormat', ...
                   'yyyy-MM-dd HH:mm:ssZ', 'TimeZone', 'UTC') ...
        , datetime('1979-05-27 07:32:00.999999-07:00', 'InputFormat', ...
                   'yyyy-MM-dd HH:mm:ss.SSSSSSSSSZ', 'TimeZone', 'UTC') ...
        , datetime('1979-05-27 07:32:00', 'TimeZone', 'UTC') ...
                 };

      % in structs for even easier reference
      matlab_strct = cellfun(@(a) struct('odt', a), matl_obj, ...
                             'uniformoutput', false);

      error_msg = 'Did not parse a fully qualified datetime successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testLocalDateTime(testCase)
      % TOML version
      toml_str = { ...
          'odt = 1979-05-27T07:32:00' ...
        , 'odt = 1979-05-27T07:32:00.999999' ...
        , 'odt = 1979-05-27 07:32:00'...
                 };

      % matlab versions, respectively
      matl_obj = { ...
          datetime('1979-05-27 07:32:00') ...
        , datetime('1979-05-27 07:32:00.999999', 'InputFormat', ...
                   'yyyy-MM-dd HH:mm:ss.SSSSSSSSS') ...
        , datetime('1979-05-27 07:32:00') ...
                 };

      % in structs for even easier reference
      matlab_strct = cellfun(@(a) struct('odt', a), matl_obj, ...
                             'uniformoutput', false);

      error_msg = 'Did not parse a local datetime successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testLocalDate(testCase)
      % TOML version
      toml_str = { ...
          'odt = 1979-05-27' ...
                 };

      % matlab versions, respectively
      matl_obj = { ...
          datetime('1979-05-27') ...
                 };

      % in structs for even easier reference
      matlab_strct = cellfun(@(a) struct('odt', a), matl_obj, ...
                             'uniformoutput', false);

      error_msg = 'Did not parse a local date successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testLocalTime(testCase)
      % TOML version
      toml_str = { ...
          'odt = 07:32:00' ...
        , 'odt = 07:32:00.999999' ...
                 };

      % matlab versions, respectively
      matl_obj = { ...
          datetime('07:32:00') ...
        , datetime('07:32:00.999999', 'InputFormat', ...
                   'HH:mm:ss.SSSSSSSSS') ...
                 };

      % in structs for even easier reference
      matlab_strct = cellfun(@(a) struct('odt', a), matl_obj, ...
                             'uniformoutput', false);

      error_msg = 'Did not parse a local time successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testArrays(testCase)
      % TOML version
      toml_str = { ...
          'key = [1, 2, 3]' ...
        , 'key = ["a", "b", "c"]' ...
        , 'key = [[1, 2], [''a'', "b"]]' ...
        , 'key = ["abcd", "comma, separated, values"]' ...
        , sprintf('key = [\n1, 2, 3\n]') ...
        , sprintf('key = [\n1,\n2,\n]') ...
                 };

      % matlab versions, respectively
      matlab_strct = { ...
          struct('key', [1, 2, 3]) ...
        , struct('key', {{'a', 'b', 'c'}}) ...
        , struct('key', {{[1, 2], {'a', 'b'}}}) ...
        , struct('key', {{'abcd', 'comma, separated, values'}}) ...
        , struct('key', [1, 2, 3]) ...
        , struct('key', [1, 2]) ...
                     };

      error_msg = 'Did not parse an array successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testInlineTables(testCase)
      % TOML version
      toml_str = { ...
          'tbl = {}' ...
        , 'tbl = {first = "John", last = "Doe"}' ...
        , 'tbl = { x = 1, y = ["a", "b"] }' ...
        , 'tbl = { type.name = "cool type" }' ...
        , 'tbl = { thing = { wow = "very cool thing" } }' ...
                 };

      % matlab versions, respectively
      matl_obj = { ...
          struct() ...
        , struct('first', 'John', 'last', 'Doe') ...
        , struct('x', 1, 'y', {{'a', 'b'}}) ...
        , struct('type', struct('name', 'cool type')) ...
        , struct('thing', struct('wow', 'very cool thing')) ...
                 };

      % in structs for even easier reference
      matlab_strct = cellfun(@(a) struct('tbl', a), matl_obj, ...
                             'uniformoutput', false);

      error_msg = 'Did not parse an inline table successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testFullTables(testCase)
      % TOML version
      toml_str = { ...
          sprintf('[table 1]\nkey1 = "some string"\nkey2 = 123') ...
        , sprintf('[table-1.table-2]\nkey1 = "some string"\nkey2 = 123') ...
        , sprintf(['[table 1]\nkey1 = "some string"\nkey2 = 123\n\n', ...
                   '[table 2]\nkey1 = "another string"\nkey2 = 456']) ...
        , sprintf('[dog."tater.man"]\ntype.name = "pug"') ...
        , sprintf('[x.y.z.w]') ...
        , sprintf('[ a.b.c ]') ...
        , sprintf('[ a . b . c ]') ...
                 };

      % matlab versions, respectively
      matlab_strct = { ...
          struct('table_1', struct('key1', 'some string', 'key2', 123)) ...
        , struct('table_1', struct('table_2', struct('key1', 'some string', ...
                                                     'key2', 123))) ...
        , struct('table_1', struct('key1', 'some string', 'key2', 123), ...
                 'table_2', struct('key1', 'another string', 'key2', 456)) ...
        , struct('dog', struct('tater_man', struct('type', struct('name', 'pug')))) ...
        , struct('x', struct('y', struct('z', struct('w', struct())))) ...
        , struct('a', struct('b', struct('c', struct()))) ...
        , struct('a', struct('b', struct('c', struct()))) ...
                 };

      error_msg = 'Did not parse a table successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testArrayedTables(testCase)
      % TOML version
      toml_str = { ...
          sprintf(['[[products]]\nname = "Hammer"\nsku = 738594937\n\n', ...
                   '[[products]]\n\n' ...
                   '[[products]]\nname = "Nail"\nsku = 28475893\ncolor = "gray"']) ...
        , sprintf(['[[fruit]]\nname = "apple"\n\n[fruit.physical]\n', ...
                   'color = "red"\nshape = "round"\n\n[[fruit.variety]]\n', ...
                   'name = "red delicious"\n\n[[fruit.variety]]\n', ...
                   'name = "granny smith"\n\n[[fruit]]\nname = "banana"\n\n', ...
                   '[[fruit.variety]]\nname = "plantain"']) ...
                 };

      % matlab versions, respectively
      matlab_strct = { ...
          struct('products', {{struct('name', 'Hammer', 'sku', 738594937), ...
                          struct(), struct('name', 'Nail', 'sku', ...
                                           28475893, 'color', 'gray')}}) ...
        , struct('fruit', {{ ...
            struct('name', 'apple', 'physical', ...
                   struct('color', 'red', 'shape', 'round'), ...
                   'variety', {{ ...
                       struct('name', 'red delicious') ...
                     , struct('name', 'granny smith') ...
                   }}), ...
            struct('name', 'banana', 'variety', {{ ...
                struct('name', 'plantain') ...
                   }}) ...
                   }})
                 };

      error_msg = 'Did not parse an array of tables successfully.';

      runStructuredTest(testCase, toml_str, matlab_strct, error_msg)
    end

    function testRedefinedKeys(testCase)
      toml_str = { ...
          sprintf('name = "Tom"\nname = "Pradyun"') ...
        , sprintf('a.b.c = 1\na.d = 2') ...
        , sprintf('a.b = 1\na.b.c = 2') ...
                 };

      testCase.verifyError(@() toml.decode(toml_str{1}), ...
       'toml:RedefinedKey', ...
       'Did not reject a redefined key.')
      testCase.verifyEqual(toml.decode(toml_str{2}), ...
        struct('a', struct('b', struct('c', 1), 'd', 2)), ...
        'Did not accept a valid nesting definition.')
      testCase.verifyError(@() toml.decode(toml_str{3}), ...
       'toml:RedefinedKey', ...
       'Did not reject a redefined key.')
    end

  end

end